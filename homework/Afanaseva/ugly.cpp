#include <iostream>
#include <fstream>
#include <map>

struct Word
{
    char* data_; // переменная в публичной области видимости, хотя логически должна быть приватной

    Word() 
    {
    }

    Word(char* data)
    {
        data_ = data; // фактически данные не переносятся, содержимое экземпляра класса может быть независимо изменено извне (не соблюдается принцип инкапсуляции)
    }

    ~Word()
    {
        delete data_; // delete применим только для данных, созданных с помощью оператора new, в данном случае будет ошибка
        data_ = 0; // присвоение ссылочной переменной целочисленного значения - очень плохо 1. несоответствие типов, 
                   // 2. логическая ошибка, так как указатель на нулевую ячейку памяти не является указателем на ноль
    }

    bool operator<(Word y) // Не очень хорошо, что экземпляр передается в функцию полностью (лишние затраты памяти), нужно передавать по константной ссылке 
    {
        return data_ < y.data_; // если объект был создан конструктором по умолчанию поведение не предсказуемо
    }
};

std::map<Word, int> freqMap; // объявлено, но не инициализировано

int main(int argc, char* argv[])
{
    auto fileName = argv[1]; // может не быть такого элемента в массиве!

    std::fstream file(fileName); // успешность открытия файла не гарантирована

    char c;

    do
    {
    	// file.get() возвращает значение int, опять несоответствие типов, для получения char надо использовать file.get(c)
        do { c = file.get(); } while (c == ' '); 

        file.put(c); // непонятно куда кладётся (не обратно), файл изменяется

        char* buf = new char[64]; // память выделяется в цикле, это плохо!

        for (int i = 0; i < 64; ++i)
        {
            buf[i] = file.get();
            if (buf[i] == ' ') // если конец строки без пробелов - неясное поведение???
                break;
        }

        do { c = file.get(); } while (c == ' ');

        Word w(buf); // buf будет удален по завершению итерации, значения, попадающие в map вообще не понятно какие будут

        if (freqMap.count(w) != 0)
            freqMap[w] = freqMap[w] + 1;
        else
            freqMap[w] = 0;
    } while (file.good());

    for (auto p : freqMap)
        std::cout << p.first.data_ << " = " << p.second; 

    return 0;
}
